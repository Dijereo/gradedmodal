initialize formulae in node:
// already done

apply static rules to node:
expand conjunctions
stop if contradiction
save disjunctions
if disjunction is sat ignore
else if disjunction is resolved expand other branch
else if disjunction is contradiction stop
else rotate
until all rotated
fork one disjunction (maybe using ke rule?)
(maybe use dpll / tt style?)
recurse
(implement backjumping?)
save open branches with modals
yield open branch with no modals
after yielded all modalless branches yield from branches with modals
stop when all branches yielded


sat graded:
apply static rules
iter over open branches
for each open branch
set up transition worlds tableaux
recurse check sat
set up ilp for stat transitions
return if found solution

types of unfeasible:
no diam gte: NotTransitionable
all nondet choices are contradictions: Contradiciton
subtransitions are unfeasible: Unfeasible
no ilp solution: No Graded Solution

cliqued:
unnest modals
expand static
choose leaf
transit
add reflexion
ilp

spotlit:
expand static lantern
choose leaf
collect psis
flatten psis
collect <>thetas
choose clique settings (+/- <>theta)
paraworlds on clique settings (+/- theta)
paraworlds (+/- psi) checking against clique settings

paraworlds
get modals from open leaves
collect submodals
paraworlds
add reflexion back to first paraworlds
ilp


types of nodes:
root
shoot
branch
leaf
stub
fruit
flower
twig
seed


ke:
keep track of formulae that are added just for contradiction but not split further

static calc: given starting formulae, iterate through open disjunctions, sorted by modal depth
- utilise backjumping

transit: given formulae, produce list of viable parallel worlds
- recursively check each is open
- utilise backjumping
- utilise better constraining

tableauview: contains data to display tableau and sat model

FT(phi) := ST(phi, w)
ST(_|_, x) := x != x
ST(T, x) := x = x
ST(pi, x) := pi(x)
ST(~phi, x) := ~(ST(phi, x))
ST(phi | psi, x) := (ST(phi, x)) | (ST(psi, x))
same for &, ->, <->
ST(<>phi, x) := ?[Y]: (rel(x, Y) & (ST(phi, Y)))
ST([]phi, x) := ![Y]: (rel(x, Y) -> (ST(phi, Y)))
ST(<>>=n phi, x) := ?[Y1,Y2,...,Yn]: (rel(x, Y1) & rel(x, Y2) & ... & rel(x, Yn) & ST(phi, Y1) & ST(phi, Y2) & ... & ST(phi, Yn) & Y1 != Y2 & ... & Y1 != Yn & ... & Y2 != Yn & ... & Yn-1 != Yn)
ST(<><=n phi, x) := ![Y0,Y1,...,Yn]: (~rel(x, Y0) | ~rel(x, Y1) | ... | ~rel(x, Yn) | ~(ST(phi, Y0)) | ~(ST(phi, Y1)) | ... | ~(ST(phi, Yn)) | Y0 == Y1 | ... | Y0 == Yn | ... | Y1 == Yn | ... | Yn-1 == Yn)
FT(D) := ![X]: ?[Y]: rel(X, Y)
FT(T) := ![X]: rel(X, X)
FT(B) := ![X, Y]: rel(X, Y) => rel(Y, X)
FT(4) := ![X, Y, Z]: rel(X, Y) & rel(Y, Z) => rel(X, Z)
FT(5) := ![X, Y, Z]: rel(X, Y) & rel(X, Z) => rel(Y, Z)

[](p->q)->[]p->[]q
p
p&~p

?[X]: (![Y]: rel(X, Y) -> (p(Y) -> q(Y))) -> ((![Y]: rel(X, Y) -> p(Y)) -> (![Y]: rel(X, Y) -> q(Y)))
![X]: ((![Y]: rel(x, Y) => (p(Y) => q(Y))) => ((![Y]: rel(x, Y) => p(Y)) => (![Y]: rel(x, Y) => q(Y))))
